---
layout: docs
title: Configuration
permalink: /docs/configuration/
---
There are two types of configurations - static and dynamic. Static configurations are defined in files or environment variables, requiring restarting app server to take effect, whereas dynamic configurations are defined in databases and updates take effect immediately. 

Most static configurations are specified in file */server/config.json* conforming to Loopback [config.json docs](http://loopback.io/doc/en/lb3/config.json.html). *NotifyBC* added some additional configurations. If you need to change, instead of updating */server/config.json* file, create [environment-specific file](http://loopback.io/doc/en/lb2/config.json.html#environment-specific-settings) such as */server/config.local.js*. *Js* file is preferred over *json* because only *js* file supports custom functions, which are demanaded by some advanced configs below. Code snippets hereafter assumes custom config file is *js*.

Dynamic configs are managed using REST [configuration api](../api-config/). 

<div class="note info">
  <h5>Why Dynamic Configs?</h5>
  <p>dynamic configs that are saved to database are needed in cases such as
  <ul>
  <li>to allow define service-specific configs such as message templates</li>
  <li>in a multi-node deployment, configs can be generated by one node and share with other nodes</li>
  </ul>
  </p>
</div>

## Admin IP List
By [design](../overview/#architecture), *NotifyBC* classifies incoming requests into four types. For a request to be classified as super-admin, the request's source ip must be in admin ip list. By default, the list contains *localhost* only as defined by *defaultAdminIps* in */server/config.json* 

```json
{
  "defaultAdminIps": [
    "127.0.0.1"
  ]
}
```
to modify, create config object *adminIps* with updated list in file */server/config.local.js* instead. For example, to add ip range *192.168.0.0/24* to the list

```js
module.exports = {
  "adminIps": [
    "127.0.0.1",
    "192.168.0.0/24"
  ]
}
```
It should be noted that *NotifyBC* may generate http requests sending to itself. These http requests are expected to be admin requests. If you have created an app cluster such as in OpenShift, you should add the cluster ip range to *adminIps*. In OpenShift, this ip range is a private ip range. In BCGov's OpenShift cluster, the ip range starts with octet 172.


<div class="note warning">
  <h5>Define static array config in one file only</h5>
  <p>
  Due to a <a href="https://github.com/strongloop/loopback-boot/issues/172">bug</a> in Loopback a config of array type such as <i>adminIps</i> cannot be merged if defined in multiple files with different length. To mitigate, only define an array config in one file.
  It is for this reason that the default admin ip list has to use a different name <i>defaultAdminIps</i> as shown above.
  </p>
</div>

## SiteMinder Reverse Proxy IP List and Trusted Reverse Proxy IP List

SiteMinder, being a gateway approached SSO solution, expects the backend HTTP access point of the web sites it protests to be firewall restricted, otherwise the SiteMinder injected HTTP headers can be easily spoofed. However, the restriction cannot be easily implemented on PAAS such as OpenShift. To mitigate, two configuration objects are introduced to create an application-level firewall, both are arrays of ip addresses in the format of [dot-decimal](https://en.wikipedia.org/wiki/Dot-decimal_notation) or [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation) notation

  * *siteMinderReverseProxyIps* contains a list of ips or ranges of SiteMinder Web Agents. If set, then the SiteMinder HTTP headers are trusted only if the request is routed from the listed nodes.
  * *trustedReverseProxyIps* contains a list of ips or ranges of trusted reverse proxies between the SiteMinder Web Agents and *NotifyBC* application. When runing on OpenShift, this is usually the OpenShift router. Express.js [trust proxy](https://expressjs.com/en/guide/behind-proxies.html) is set to this config object.

By default *trustedReverseProxyIps* is empty and *siteMinderReverseProxyIps* contains only localhost as defined by *defaultSiteMinderReverseProxyIps* in */server/config.json* 

```json
{
  "defaultSiteMinderReverseProxyIps": [
    "127.0.0.1"
  ]
}
```

To modify, add following objects to file /server/config.local.js

```js
module.exports = {
  "siteMinderReverseProxyIps":[
    "130.32.12.0"
  ],
  "trustedReverseProxyIps":[
    "172.17.0.0/16"
  ]
}
```

The rule to determine if the incoming request is authenticated by SiteMinder is

1. obtain the real client ip address by filtering out trusted proxy ips according to [Express behind proxies](https://expressjs.com/en/guide/behind-proxies.html)
2. if the real client ip is contained in *siteMinderReverseProxyIps*, then the request is from SiteMinder, and its SiteMinder headers are trusted; otherwise, the request is considered as directly from internet, and its SiteMinder headers are ignored.

## SMTP
By default *NotifyBC* acts as the SMTP server itself and connects directly to recipient's SMTP server. You can setup a SMTP relay by adding following *smtp* config object to */server/config.local.js*

```js
module.exports = {
  "smtp": {
    "host": "smtp.foo.com",
    "port": 25,
    "ignoreTLS": true,
    "secure": false,
    "pool": true
  }
}
```
Check out [Nodemailer](https://community.nodemailer.com/2-0-0-beta/setup-smtp/) for other config options that you can define in *smtp* object. Using SMTP relay and fine-tuning some options are critical for performance. See [benchmark advices](../benchmarks/#advices). There are also options allowing you to throttle down throughput if needed.

## SMS
*NotifyBC* depends on underlying SMS service providers to deliver SMS messages. The supported service providers are

 * Twilio (default)

Only one service provider can be chosen per installation. To change service provider, add following *smsServiceProvider* config object to file */server/config.local.js*

```js
module.exports = {
  "smsServiceProvider": "twilio"
}
```
The rest configs are service provider specific. You should have an account with the chosen service provider before proceeding.

### Twilio
Add *sms.twilio* config object to file */server/config.local.js*

```js
module.exports = {
  "sms": {
    "twilio": {
      "accountSid": "<AccountSid>",
      "authToken": "<AuthToken>",
      "fromNumber": "<FromNumber>"
    }
  }
}
```
Obtain *\<AccountSid\>*, *\<AuthToken\>* and *\<FromNumber\>* from your Twilio account.

## Subscription/Unsubscription
Configs in this section customize behavior of subscription and unsubscription workflow. They are all sub-properties of config object *subscription*. This object can be defined as service-agnostic static config as well as service-specific dynamic config, which overrides the static one on a service-by-service basis. Default static config is defined in file */server/config.json*. There is no default dynamic config.

To customize static config, create the config object *subscription* in file */server/config.local.js*

```js
module.exports = {
  "subscription": {
    ...
  }
}
```

to create a service-specific dynamic config, use REST [config api](../configuration/)

```sh
~ $ curl -X POST http://localhost:3000/api/configurations \
-H 'Content-Type: application/json' \
-H 'Accept: application/json' -d @- << EOF 
{ 
  "name": "subscription", 
  "serivceName": "myService", 
  "value": { 
     ...
  } 
}
EOF
```
Sub-properties denoted by ellipsis in the above two code blocks are documented below. A service can have at most one dynamic subscription config.

### Confirmation Request Message
To prevent *NotifyBC* from being used as spam engine, when a subscription request is sent by user (as opposed to admin) without encryption, the content of confirmation request sent to user's notification channel has to come from a pre-configured template as opposed to be specified in subscription request. 

The following default subscription sub-property *confirmationRequest* defines confirmation request message settings for different channels 

```json
{
  "subscription": {
    "confirmationRequest": {
      "sms": {
        "confirmationCodeRegex": "\\d{5}",
        "sendRequest": true,
        "textBody": "Enter {confirmation_code} on screen"
      },
      "email": {
        "confirmationCodeRegex": "\\d{5}",
        "sendRequest": true,
        "from": "no_reply@invlid.local",
        "subject": "Subscription confirmation",
        "textBody": "Enter {confirmation_code} on screen",
        "htmlBody": "Enter {confirmation_code} on screen"
      }
    }
  }
}
```

### Confirmation Verification Acknowledgement Messages
You can customize *NotifyBC*'s on-screen response message to confirmation code verification requests. The following is the default settings

```json
{
  "subscription": {
    "confirmationAcknowledgements": {
      "successMessage": "You have been subscribed.",
      "failureMessage": "Error happened while confirming subscription."
    }
  }
}
```
In addition to customizing the message, you can define a redirect URL instead of displaying *successMessage* or *failureMessage*. For example, to redirect on-screen acknowledgement to a page in your app for service *myService*, create a dynamic config by calling REST config api  

```sh
~ $ curl -X POST 'http://localhost:3000/api/configurations' \
-H 'Content-Type: application/json' \
-H 'Accept: application/json' -d @- << EOF
{  
  "name": "subscription",  
  "serivceName": "myService", 
  "value": { 
    "confirmationAcknowledgements": { 
      "redirectUrl": "https://myapp/subscription/acknowledgement" 
    } 
  } 
}
EOF
```
If error happened during unsubscription, query string *?err=\<error\>* will be appended to *redirectUrl*.


### Anonymous Unsubscription
For anonymous subscription, *NotifyBC* supports one-click opt-out by allowing unsubscription URL provided in notifications. To thwart unauthorized unsubscription attempts, *NotifyBC* implemented and enabled by default two security measurements 

* Anonymous unsubscription request requires unsubscription code, which is a random string generated at subscription time. Unsubscription code reduces brute force attack risk by increasing size of key space. Without it, an attacker only needs to successfully guess subscription id. Be aware, however, the unsubscription code has to be embedded in unsubscription link. If the user forwarded a notification to other people, he/she is still vulnerable to unauthorized unsubscription.
* Acknowledgement notification - a (final) notification is sent to user acknowledging unsubscription, and offers a link to revert had the change been made unauthorized. A deleted subscription (unsubscription) may have a limited lifetime (30 days by default) according to retention policy defined in [cron job](#cron-job) so the reversion can only be performed within the lifetime.  

You can customize anonymous unsubscription settings by changing the *anonymousUnsubscription* configuration. Following is the default settings defined in [config.json](https://github.com/bcgov/MyGovBC-notification-server/blob/master/server/config.json)
 
```json
{
  "subscription": {
    ...
    "anonymousUnsubscription": {
      "code": {
        "required": true,
        "regex": "\\d{5}"
      },
      "acknowledgements":{
        "onScreen": {
          "successMessage": "You have been un-subscribed.",
          "failureMessage": "Error happened while un-subscribing."
        },
        "notification":{
          "email": {
            "from": "no_reply@invlid.local",
            "subject": "Un-subscription acknowledgement",
            "textBody": "This is to acknowledge you have been un-subscribed from receiving notification for {unsubscription_service_names}. If you did not authorize this change or if you changed your mind, click {unsubscription_reversion_url} to revert."
          }
        }
      }
    }
  }
}
```
The settings control whether or not unsubscription code is required, its RegEx pattern, and acknowledgement message templates for both on-screen and push notifications. Customization should be made to file */server/config.local.js* for static config or using configuration api for service-specific dynamic config.

To disable acknowledgement notification, set *subscription.anonymousUnsubscription.acknowledgements.notification* or a specific channel underneath to *null*

```js
module.exports = {
  subscription:{
    anonymousUnsubscription: {
      acknowledgements:{
        notification: null
      }
    }
  }
}
```

For on-screen acknowledgement, you can define a redirect URL instead of displaying *successMessage* or *failureMessage*. For example, to redirect on-screen acknowledgement to a page in your app for all services, create following config in file */server/config.local.js* 

```js
module.exports = {
  "subscription":{
    "anonymousUnsubscription": {
      "acknowledgements":{
        "onScreen": {
          "redirectUrl": "https://myapp/unsubscription/acknowledgement"
        }
      }
    }
  }
}
```
If error happened during unsubscription, query string *?err=\<error\>* will be appended to *redirectUrl*.

<a name="anonymousUndoUnsubscription"></a>
You can customize message displayed on-screen when user clicks revert unsubscription link in the acknowledgement notification. The default settings are

```json
{
  "subscription": {
    "anonymousUndoUnsubscription":{
      "successMessage": "You have been re-subscribed.",
      "failureMessage": "Error happened while re-subscribing."
    }
  }
}
```
You can redirect the message page by defining *anonymousUndoUnsubscription.redirectUrl*.

## Notification 
Configs in this section customize the handling of notification request or generating notifications from RSS feeds.  They are all sub-properties of config object *notification*. Service-agnostic  configs are static and service-dependent configs are dynamic. 

### RSS Feeds
*NotifyBC* can generate broadcast push notifications automatically by polling RSS feeds periodically and detect changes by comparing with an internally maintained history list. The polling frequency, RSS url, RSS item change detection criteria, and message template can be defined in dynamic configs.  

<div class="note warning">
  <h5>Only first page is retrived for paginated RSS feeds</h5>
  <p>If a RSS feed is paginated, <i>NotifyBC</i> only retrives the first page rather than auto-fetch subsequent pages. Hence paginated RSS feeds should be sorted descendingly by last modified timestamp. Refresh interval should be adjusted small enough such that all new or updated items are contained in first page.</p>
</div>


For example, to notify subscribers of *myService* on updates to feed *http://my-serivce/rss*, create following config item using [POST configuration API](../api-config/#create-a-configuration)

```json
{
  "name": "notification",
  "serviceName": "myService",
  "value": {
    "rss": {
      "url": "http://my-serivce/rss",
      "timeSpec": "* * * * *",
      "itemKeyField": "guid",
      "outdatedItemRetentionGenerations": 1,
      "includeUpdatedItems": true,
      "fieldsToCheckForUpdate": [
        "title",
        "pubDate",
        "description"
      ]
    },
    "httpHost": "http://localhost:3000",
    "messageTemplates": {
      "email": {
        "from": "no_reply@invlid.local",
        "subject": "{title}",
        "textBody": "{description}",
        "htmlBody": "{description}"
      }
    }
  }
}
```
The config items in the *value* field are

* rss
  * url: RSS url
  * <a name="timeSpec"></a>timeSpec: RSS poll frequency, a space separated fields conformed to [unix crontab format](https://www.freebsd.org/cgi/man.cgi?crontab(5)) with an optional left-most seconds field. See [allowed ranges](https://github.com/kelektiv/node-cron#cron-ranges) of each field
  * itemKeyField: rss item's unique key field to identify new items. By default *guid*
  * outdatedItemRetentionGenerations: number of last consecutive polls from which results an item has to be absent before the item can be removed from the history list. This config is designed to prevent multiple notifications triggered by the same item because RSS poll returns inconsistent results, usually due to a combination of pagination and lack of sorting. By default 1, meaning the history list only keeps the last poll result
  * includeUpdatedItems: whether to notify also updated items or just new items. By default *false*  
  * fieldsToCheckForUpdate: list of fields to check for updates if *includeUpdatedItems* is *true*. By default *["pubDate"]*
* httpHost: the http protocol, host and port used by [mail merge](../overview/#mail-merge). If missing, the value is auto-populated based on the REST request that creates this config item.
* messageTemplates: channel-specific message template supporting dynamic token as shown. Message template fields is same as those in [notification api](../api-notification/#field-message)

### Broadcast Push Notification Task Concurrency
When a broadcast push notification request is received, *NotifyBC* divides subscribers into chunks and generates a HTTP sub-request for each chunk.  The sub-requests are submitted in batches back to ( preferably load-balanced) server cluster to achieve horizontal scaling. Sub-requests in a batch are submitted concurrently. Batches are processed serially, i.e. a batch is held until previous batch is completed. The chunk and batch size is determined by config *broadcastSubscriberChunkSize* and *broadcastSubRequestBatchSize* respectively with default value defined in */server/config.json*

```json
{
  "notification": {
    "broadcastSubscriberChunkSize": 1000,
    "broadcastSubRequestBatchSize": 10
  }
}
```

To customize, create the config with updated value in file */server/config.local.js*.

When handling a sub-request, *NotifyBC* dispatches notifications to all subscribers in the chunk concurrently. 

If total number of subscribers is less than *broadcastSubscriberChunkSize*, then no sub-requests are spawned. Instead, the main request dispatches all notifications. 

### Broadcast Push Notification Custom Filter Functions
<div class="note info">
  <h5>Advanced Topic</h5>
  <p>
  Defining custom function requires knowledge of JavaScript and understanding how external libraries are added and referenced in NodeJS. Setting a development environment to test the custom function is also recommended.
  </p>
</div>

To support rule-based notification event filtering, *NotifyBC* uses a [modified version](https://github.com/f-w/jmespath.js) of [jmespath](http://jmespath.org/) to implement json query. The modified version allows defining custom functions that can be used in  [broadcastPushNotificationFilter](../api-subscription#broadcastPushNotificationFilter) field of subscription API. The functions must be implemented using JavaScript in config *notification.broadcastCustomFilterFunctions*. For example, the case-insensitive string matching function *contains_ci* shown in the example of that field can be created in file */server/config.local.js*

```js
'use strict'
var _ = require('lodash')
module.exports = {
  notification: {
    broadcastCustomFilterFunctions: {
      contains_ci: {
        _func: function(resolvedArgs) {
          if (!resolvedArgs[0] || !resolvedArgs[1]) {
            return false
          }
          return (
            _.toLower(resolvedArgs[0]).indexOf(_.toLower(resolvedArgs[1])) >= 0
          )
        },
        _signature: [
          {
            types: [2]
          },
          {
            types: [2]
          }
        ]
      }
    }
  }
}
```
Consult jmespath.js source code on the [functionTable syntax](https://github.com/f-w/jmespath.js/blob/master/jmespath.js#L1127) and [type constants](https://github.com/f-w/jmespath.js/blob/master/jmespath.js#L132) used by above code. Note the function can use any external libraries (*[lodash](https://lodash.com/)* in this case) referenced in [package.json](https://github.com/bcgov/MyGovBC-notification-server/blob/master/package.json). 

<div class="note">
  <h5>ProTips™ reference additional libraries modules</h5>
  <p>You can add npm modules to package.json but the file maybe overwritten when upgrading <i>NotifyBC</i>. To avoid, add by running command <i><a href="https://docs.npmjs.com/cli/install">npm install &lt;your_package&gt;</a></i> during build.</p>
</div>


## Database
By default *NotifyBC* uses in-memory database backed up by file in */server/database/data.json* for local and docker deployment and MongoDB for OpenShift deployment. To use MongoDB for non-OpenShift deployment, add file */server/datasources.local.json* with MongoDB connection information such as following:

```json
{
 "db": {
   "name": "db",
   "connector": "mongodb",
   "host": "127.0.0.1",
   "database": "notifyBC",
   "port": 27017
 }
}
```

See [LoopBack MongoDB data source](https://docs.strongloop.com/display/public/LB/MongoDB+connector#MongoDBconnector-CreatingaMongoDBdatasource) for more configurable properties.

## Node Roles
In a multi-node deployment, some tasks should only be run by one node. That node is designated as *master*. The distinction is made using environment variable *NOTIFYBC_NODE_ROLE*. Setting to anything other than *slave*, including not set, will be regarded as *master*.

## Cron Jobs
*NotifyBC* runs several cron jobs described below. These jobs are controlled by sub-properties defined in config object *cron*. To change config, create the object and properties in file */server/config.local.js*.

By default cron jobs are enabled. In a multi-node deployment, cron jobs should only run on the [master node](#node-roles) to ensure single execution.

### Purge Data
This cron job purges old notifications and subscriptions. The default frequency of cron job and retention policy are defined by *cron.purgeData* config object in file */server/config.json*

```json
 {
   "cron": {
    "purgeData":{
      "timeSpec": "0 0 1 * * *",
      "pushNotificationRetentionDays" : 30,
      "expiredInAppNotificationRetentionDays" : 30,
      "nonConfirmedSubscriptionRetentionDays" : 30,
      "defaultRetentionDays": 30
    }
   }
 }
```

The config items are

* timeSpec: follows [same syntax described above](#timeSpec).
* pushNotificationRetentionDays: the retention days of push notifications
* expiredInAppNotificationRetentionDays: the retention days of expired inApp notifications
* nonConfirmedSubscriptionRetentionDays: the retention days of non-confirmed subscriptions, i.e. all unconfirmed and deleted subscriptions
* defaultRetentionDays: if any of the above retention day config item is omitted, default retention days is used as fall back.

To change a config item, set the config item in file */server/config.local.js*. For example, to run cron jobs at 2am daily, add following object to */server/config.local.js*

```js
module.exports = {
   "cron": {
    "purgeData":{
      "timeSpec": "0 0 2 * * *"
    }
   }
 }
```

### Dispatch Live Notifications
This cron job sends out future-dated notifications when the notification becomes current. The default config is defined by *cron.dispatchLiveNotifications* config object in file */server/config.json*

```json
 {
   "cron": {
    "dispatchLiveNotifications":{
      "timeSpec": "0 * * * * *"
    }
   }
 }
```
*timeSpec* follows [same syntax described above](#timeSpec).

### Check Rss Config Updates
This cron job monitors RSS feed notification dynamic config items. If a config item is created, updated or deleted, the cron job starts, restarts, or stops the RSS-specific cron job. The default config is defined by *cron.checkRssConfigUpdates* config object in file */server/config.json*

```json
 {
   "cron": {
    "checkRssConfigUpdates": {
      "timeSpec": "0 * * * * *"
    }
   }
 }
```
*timeSpec* follows [same syntax described above](#timeSpec). Note this *timeSpec* doesn't control the RSS poll frequency (which is defined in dynamic configs and is service specific), instead it only controls the frequency to check for dynamic config changes. 

## RSA Keys
When *NotifyBC* starts up, it checks if an RSA key pair exists in database as dynamic config. If not it will generate the dynamic config and save it to database. This RSA key pair is used to exchange confidential information with third party server applications through user's browser. For an example of use case, see [Subscription API](../api-subscription/). To make it work, send the public key to the third party and have their server app encrypt the data using the public key. To obtain public key, call the REST [Configuration API](..api-config/#get-configurations) from an admin ip, for example, by running *cURL* command
```bash
~ $ curl -X GET 'http://localhost:3000/api/configurations?filter=%7B%22where%22%3A%20%7B%22name%22%3A%20%22rsa%22%7D%7D'
```
or you can open API explorer, expand `GET /configurations` and set filter to 

```json
{"where": {"name": "rsa"}}
```

The response should be something like

```json
[
  {
    "name": "rsa",
    "value": {
      "private": "-----BEGIN RSA PRIVATE KEY-----\nMIIEpgIBAAKCAQEA8Hl+/cF3AOxKVRHtZpeSDM+LLGc2hkDkKxRXe72maUAzDUoO\noNd6wd02Cf6iO7kj0RSDHXUyINxCgvXy2Q7gME4zRN5WG4ItWZ7FITeNgJJW1r+J\nshDjTwKVpMvcKHy0vyUl25ah7hnwGK6PbJvFWMmtIBw6Rs5DaERAlmilgkuUgdri\naA4YhhS4pCJLvO2p9wZd+dLWUT+tpsOZGeecC8If3fyShgrocMbd8pYYDzf65oCt\nVaLaNdERaIJSDcmbHxFpeBdEQEzxw2qRPbUCnSgQb8cVFLJ2eOEn5LylWhU96A1S\n3w1IlRm5N2zG0En58Vruo26gEtl5KFu0zivlawIDAQABAoIBAQCAawFsFcKtVYIk\nh9xVax/tg2/5GG0/qKuwbb6CMDcMAeLBeAjzz96YZL+U+sw8RJRh9ShHtOw+LCHA\nugMj8xO5+Cjc4DbvnccGEwmGwZnpTTzelY687tPUv7aWON+rJ12GrhnXeEulUWis\nZZvmDhGHZrvzZ9+fLEtHBRvQtrWcLCN0G5l1Z1KEWUj23vn1HZpfNvqigIbC05Pq\nWUewRZShHUklhzky6DwLklWUKv2951ypd5CHhYfXn0eXjeyqcoYeZzoCSGqtvZar\nVVOCPBKPn3cLZVKzYd02WO4CV07SpHCBtYPWf4OvXbOY6wV1Vc92S0K+ijASDDc0\nB7Vjgb8RAoGBAPg4dSbn9GWNHydveidi2Zt4kftEW18C9xHbJ3t+QkhpLjq2kwcY\no0iOWkEd4d1l0lKAVanBQazrazKiSyq1PJSJDyL3osHItA7Twq+gCXOfXw/0LbJh\napK5DH3S2ZTM42wOdZLYIHvSqRuYUmnzhy9+Ads87b/ICCctUMCLz1afAoGBAPgC\n4/zE/Au/A3wb48AywfmJ5kqPO0V7lqLrn/aBwdF1H/DHQ95cSuKrTEIysZxz52bh\n7mAHjnWnY4zFNaUvcruHw78NOxUJvje8cDIUsrTefh+qmctiGR119z7iso9FlsxR\np/o5BVT/K8q76xtkpOln2A0rc8sBNwtCoeeUzfm1AoGBAInH/O99raF49iQTswCN\n1DCCerW4uedBZBebSI06BlzfVXPtyCsWN/ycV+jxR2B3lomJBwPVbDkp7DUM9SBd\nvaTNd4N3ZfafC6N3VAfck6KEgmX+qibsABY1dYOaOIBqQorGc+jw4wcYZhoVMRny\nvcVU8n7ZkTb1N+FXPA3FDXANAoGBAOuSg0/TI71cgEjgjOJA1DLco1vq1NfY3mp9\n+QFCmwEDiYVBINwTOiY3o0W1tTLwfLoinDOmudBTYKGTqLLwcMBj4rCUNqxzBrUW\nTlOjiWN3esFFYLPoyAZNyL14wzaHWQdWAIISq1fi0IvPFzB71pDFTFimD2SiENCn\nR/YaR9OJAoGBAM21MRvTEMHF/EvqZ/X6t2zm9dtA22L2LeVy68aEdo82F/1RFvCM\nGBWjGS7G7fXk/tV/YHbjibhgktvLu3Rss1wlHfGEjtDAIdp9dqH0cNxMgy/eTfoy\nFfzV3l7pNSdILn1bNqoMz9CaYK7CGIYpBWCbRJlRSYw2FHJwl5tzgmkk\n-----END RSA PRIVATE KEY-----",
      "public": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8Hl+/cF3AOxKVRHtZpeS\nDM+LLGc2hkDkKxRXe72maUAzDUoOoNd6wd02Cf6iO7kj0RSDHXUyINxCgvXy2Q7g\nME4zRN5WG4ItWZ7FITeNgJJW1r+JshDjTwKVpMvcKHy0vyUl25ah7hnwGK6PbJvF\nWMmtIBw6Rs5DaERAlmilgkuUgdriaA4YhhS4pCJLvO2p9wZd+dLWUT+tpsOZGeec\nC8If3fyShgrocMbd8pYYDzf65oCtVaLaNdERaIJSDcmbHxFpeBdEQEzxw2qRPbUC\nnSgQb8cVFLJ2eOEn5LylWhU96A1S3w1IlRm5N2zG0En58Vruo26gEtl5KFu0zivl\nawIDAQAB\n-----END PUBLIC KEY-----"
    },
    "id": "591cda5d6c7adec42a1874bc",
    "updated": "2017-05-17T23:18:53.385Z"
  }
]
```

The public key is the string `-----BEGIN PUBLIC KEY-----...-----END PUBLIC KEY-----`

In a multi-node deployment, when the cluster is first started up, database is empty and rsa key pair doesn't exist. To prevent multiple rsa keys being generated by different nodes, only the [master node](#node-roles) can generate the rsa key pair. other nodes will wait for the key pair available in database before proceeding with rest bootstrap.

<div class="note warning">
  <h5>Expose RSA public key to only trusted party</h5>
  <p>Dispite of the adjective public, NotifyBC's public key should only be distributed to trusted third party. The trusted third party should only use the public key at server backend. Using the public key in client-side JavaScript poses a security loophole.</p>
</div>

## Internal Http Host
By default, HTTP requests submitted by *NotifyBC* back to itself will be sent to the host of the incoming HTTP request that spawns such internal requests. But if config *internalHttpHost*, which has no default value, is defined, for example in file */server/config.local.js*
  
```js
module.exports = {
  "internalHttpHost" : "http://notifybc:3000"
}
```
then the HTTP request will be sent to the configured host url. An internal request can be generated, for example, as a [sub-request of broadcast push notification](#broadcast-push-notification-task-concurrency) described above. *internalHttpHost* shouldn't be accessible from internet. 

All internal requests are supposed to be admin requests. The purpose of *internalHttpHost* is to facilitate identifying the internal server ip as admin ip.
 

<div class="note">
  <h5>ProTips™ OpenShift Use Case</h5>
  <p>The OpenShift deployment script has set <i>internalHttpHost</i> to service url <i>http://notify-bc:3000</i> in file <a href="https://github.com/bcgov/MyGovBC-notification-server/blob/master/.s2i/configs/config.production.json">config.production.json</a> so you shouldn't re-define it in <i>/server/config.local.js</i>. The source ip in such case would be in a private OpenShift ip range. You should add this private ip range to <a href="#admin-ip-list">admin ip list</a>. The private ip range varies from OpenShift installation. In BCGov's cluster, it starts with octet 172.</p>
</div>

## List-unsubscribe by Email
Some email clients provide a consistent UI to unsubscribe if an unsubscription email address is supplied. For example, newer iOS built-in email app will display following banner

![list unsubscription]({{site.baseurl}}/img/list-unsubscription.png)

To support this unsubscription method, *NotifyBC* implemented a custom inbound SMTP server based on Nodemailer [SMTP Server](https://nodemailer.com/extras/smtp-server/). The SMTP server transforms received emails sent to address *un-{subscriptionId}-{unsubscriptionCode}@{unsubscriptionEmailDomain}* to *NotifyBC* unsubscribing API calls and denies all non conforming emails. This unsubscription email address is generated by *NotifyBC* and set in header *List-Unsubscribe* of all notification emails if static config *subscription.unsubscriptionEmailDomain*, which has no default value, is defined in */server/config.local.js*

```js
module.exports = {
  ...
  subscription: {
    ...
    unsubscriptionEmailDomain: 'invlid.local'
  }
}
```
The config *subscription.unsubscriptionEmailDomain* will then be used to substitute token *{unsubscriptionEmailDomain}* in the unsubscription email address.

The value of the config should be resolved to a host where one of the following servers is listening on port 25 opening to internet

1. *NotifyBC*, if it can be installed on such internet-facing server; otherwise,
2. a tcp proxy server, such as nginx with stream proxy module that can proxy tcp port 25 traffic to backend *NotifyBC* instances.

### Inbound SMTP Server
Regardless which above option is chosen, you need to config inbound SMTP server by adding following static config *inboundSmtpServer* to file */server/config.local.js*

```js
module.exports = {
  ...
  inboundSmtpServer: {
    listeningSmtpPort: 25,
    apiUrlPrefix: 'http://localhost:3000/api',
    options: {
      secure: true
    }
  },
}
```
where

* *listeningSmtpPort* should be set to 25 if option 1 above is chosen. For options 2, *listeningSmtpPort* can be set to any opening port. On Unix, *NotifyBC* has to be run under *root* account to bind to port 25
* *apiUrlPrefix* is *NotifyBC* external api url prefix. It is used by inbound SMTP server to generate unsubscription api calls. If missing, the value is default to *http://localhost:3000/api*
* *options.secure* tells whether the connection will use TLS. The default is false. The *options* object is passed to Nodemailer SMTP Server. You can also set [other options](https://nodemailer.com/extras/smtp-server/#step-3-create-smtpserver-instance) as long as they are not [overridden by *NotifyBC*](https://github.com/bcgov/MyGovBC-notification-server/blob/master/server/smtp-server.js#L45)

<div class="note info">
  <h5>Inbound SMTP Server on OpenShift</h5>
  <p>OpenShift deployment template deploys an inbound SMTP server. Due to the limitation that OpenShift can only expose port 80 and 443 to external, to use the SMTP server, you have to setup a TCP proxy server (i.e. option 2).  The inbound SMTP server is exposed as ${INBOUND_SMTP_DOMAIN}:443 , where ${INBOUND_SMTP_DOMAIN} is a template parameter which in absence, a default domain will be created. Configure your TCP proxy server to route traffic to ${INBOUND_SMTP_DOMAIN}:443 over TLS.</p>
  <p>&nbsp;</p>
  <p>Also, You need to populate sub-field <i>apiUrlPrefix</i> by editing configMap <i>notify-bc</i>. OpenShift deployment template has populated all other sub-fields of <i>inboundSmtpServer</i>. 
  </p>
</div>

### TCP Proxy Server
If *NotifyBC* is not able to bind to port 25 that opens to internet, you can setup a TCP Proxy Server such as Nginx with [ngx_stream_proxy_module](http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html). For example, the following nginx config will proxy SMTP traffic from port 25 to a *NotifyBC* inbound SMTP server running on OpenShift

```
stream {
    server {
        listen 25;
        proxy_pass ${INBOUND_SMTP_DOMAIN}:443;
        proxy_ssl on;
        proxy_ssl_verify off;
        proxy_ssl_server_name on;
        proxy_connect_timeout 10s;
    }
}
```
Replace *${INBOUND_SMTP_DOMAIN}* with the inbound SMTP server route domain.